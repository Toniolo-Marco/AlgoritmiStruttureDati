\chapter{Programmazione dinamica}
Si dice programmazione dinamica un metodo per dividere un problema ricorsivamente in sottoproblemi in modo che ogni sottoproblema venga rivolto una volta sola e la sua soluzione venga memorizzata in
una tabella. Se un sottoproblema deve essere risolto nuovamente si ottiene la sua soluzione dalla tabella (lookup in $O(1)$).
\section{Approccio generale}
Se si parte da un problema di ottimizzazione si definisce la soluzione in maniera ricorsiva, successivamente si definisce il valore della soluzione in maniera ricorsiva (primo passo per problemi di conteggio). Se da
qui non sono presenti sottoproblemi ripetuti si utilizza divide et impera; se sono presenti sottoproblemi ripetuti e bisogna risolverli tutti si utilizza la programmazione dinamica, se non devono essere risolti tutti
si usa memoization. Dalla tabella delle soluzioni si ottiene l'output numerico o la ricostruzione della soluzione che permette di arrivare alla soluzione ottima. 
\subsection{Evitare di risolvere i problemi pi\`u di una volta}
Quando si risolve un problema si memorizza il risultato ottenuto in una tabella DP, che pu\`o essere un vettore, una matrice o un dizionario. La tabella deve contenere un elemento per ogni sottoproblema che
deve essere risolto.
\begin{itemize}
\item Casi base: si memorizzano i casi base direttamente nella tabella.
\item Iterazione bottom-up: si parte dai sottoproblemi che possono essere risolti direttamente a partire dai casi base, si sale verso problemi sempre pi\`u grandi fino a raggiungere il problema originale. 
\end{itemize} 
\subsection{Ricostruire la soluzione}
Per ricostruire la soluzione si parte dalla definizione ricorsiva del problema, la dimensione di $n$ indica l'indice sulla tabella che si deve controllare e si definisce un controllo su quale delle chiamate ricorsive 
viene realmente effettuata.
\section{Memoization}
Questa tecnica fonde l'approccio di memorizzazione della programmazione dinamica con quello top-down di divide-et-impera: si crea una tabella DP inizializzata con un valore speciale ad indicare che un certo 
sottoproblema non \`e ancora stato risolto. Ogni volta che si deve risolvere un sottoproblema si controlla nella tabella se \`e gi\`a stato risolto precedentemente:
\begin{itemize}
\item gi\`a risolto: si utilizza il risultato della tabella.
\item non risolto: si calcola il risultato e lo si memorizza
\end{itemize}
In questo modo ogni sottoproblema viene calcolato una sola volta e memorizzato come nella versione bottom-up. Questa tecnica presenta vantaggi quando invece di utilizzare una tabella si utilizza un dizionario 
in quanto non \`e pi\`u necessario fare inizializzazione e il costo di esecuzione passa da $O(nC)$ a $O(\min(2^n, nC)$.
\lstinputlisting[caption={Memoization automatica in Python}, language={python}]{../Codice/MemoizationAutomatica.py}
\section{Problemi}
\subsection{Domino lineare}
Il gioco del domino \`e basato su tessere di dimensione $2\times 1$. Si scriva un algoritmo efficiente che prenda in input un intero $n$ e restituisca il numero di possibili disposizioni $n$ di tessere in un 
rettangolo $2\times n$.
\subsubsection{Definizione ricorrenza}
Si definisca una formula ricorsiva $DP[n]$ che permetta di calcolare il numero di disposizioni possibili quando si hanno $n$ tessere. Con $n=0$ esiste una sola disposizione possibile, con $n=1$ esiste ancora una
sola disposizione possibile. Mettendo una tessera in verticale si risolve il problema di dimensione $n-1$, con una in orizzontale ne devo mettere due e risolvo il problema di dimensione $n-2$. Essendo un 
problema di conteggio queste due possibilit\`a si sommano insieme:
$$
DP[n]=
\begin{cases}
1\quad & n\le 1\\
DP[n-2] + DP[n-1]& n>1
\end{cases}
$$
Si noti come $DP[n]$ \`e pari al $n+1$-esimo numero della serie di Fibonacci. 
\subsubsection{Algoritmo ricorsivo}
\begin{algorithm}[H]
\DontPrintSemicolon
\SetKwComment{comment}{$\%$}{}

\SetKw{Int}{int}
\SetKw{Boolean}{boolean}
\SetKw{New}{new}
\SetKw{True}{true}
\SetKw{False}{false}
\SetKw{Not}{not}
\SetKw{And}{and}
\SetKw{Down}{down}
\SetKw{To}{to}
\SetKw{New}{new}
\SetKw{Return}{return}
\SetKw{Print}{print}

\SetKwData{Item}{Item}
\SetKwData{Mfset}{Mfset}
\SetKwData{Graph}{Graph}
\SetKwData{N}{n}
\SetKwData{Space}{ }
\SetKwData{Parent}{parent}
\SetKwData{Rank}{rank}

\SetKwFunction{Domino}{domino1}
\SetKwFunction{Pivot}{pivot}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}

\caption{\protect\Int \protect\Domino{\protect\Int n}}
\uIf{n $\le$ 1}{
	\Return 1\;
}
\Else{
	\Return \Domino{n - 1} + \Domino{n - 2}\;
}
\end{algorithm}
\paragraph{Complessit\`a}
L'equazione di ricorrenza associata \`e:
$$
T(n)=
\begin{cases}
1\quad & n\le 1\\
T(n-2) + T(n-1) + 1& n>1
\end{cases}
$$
Che utilizzando il master theorem per la ricorrenza lineare di ordine costante si ottiene una complessit\`a pari a $T(n)=\Theta(2^n)$.
\subsubsection{Algoritmo iterativo}
\begin{algorithm}[H]
\DontPrintSemicolon
\SetKwComment{comment}{$\%$}{}

\SetKw{Int}{int}
\SetKw{Boolean}{boolean}
\SetKw{New}{new}
\SetKw{True}{true}
\SetKw{False}{false}
\SetKw{Not}{not}
\SetKw{And}{and}
\SetKw{Down}{down}
\SetKw{To}{to}
\SetKw{New}{new}
\SetKw{Return}{return}
\SetKw{Print}{print}

\SetKwData{Item}{Item}
\SetKwData{Mfset}{Mfset}
\SetKwData{Graph}{Graph}
\SetKwData{N}{n}
\SetKwData{Space}{ }
\SetKwData{Parent}{parent}
\SetKwData{Rank}{rank}

\SetKwFunction{Domino}{domino2}
\SetKwFunction{Pivot}{pivot}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}

\caption{\protect\Int \protect\Domino{\protect\Int n}}
\Int[] DP = \New \Int$[0\dots n]$\;
DP[0] = DP[1] = 1\;
\For{\Int i = 2 \To n}{
	DP[i] = DP[i - 1] + DP[i-2]\:
}
\Return DP[n]\;
\end{algorithm}
\paragraph{Complessit\`a}
Ha complessit\`a temporale $T(n)=\Theta(n)$ e spaziale $S(n)=\Theta(n)$.
\paragraph{Miglioramento}
Si pu\`o rendere con complessit\`a spaziale costante $S(n)=\Theta(n)$.
\begin{algorithm}[h]
\DontPrintSemicolon
\SetKwComment{comment}{$\%$}{}

\SetKw{Int}{int}
\SetKw{Boolean}{boolean}
\SetKw{New}{new}
\SetKw{True}{true}
\SetKw{False}{false}
\SetKw{Not}{not}
\SetKw{And}{and}
\SetKw{Down}{down}
\SetKw{To}{to}
\SetKw{New}{new}
\SetKw{Return}{return}
\SetKw{Print}{print}

\SetKwData{Item}{Item}
\SetKwData{Mfset}{Mfset}
\SetKwData{Graph}{Graph}
\SetKwData{N}{n}
\SetKwData{Space}{ }
\SetKwData{Parent}{parent}
\SetKwData{Rank}{rank}

\SetKwFunction{Domino}{domino3}
\SetKwFunction{Pivot}{pivot}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}

\caption{\protect\Int \protect\Domino{\protect\Int n}}
\Int $DP_0$ = 1\;
\Int $DP_1$ = 1\;
\Int $DP_2$ = 1\;
\For{\Int i = 2 \To n}{
	$DP_0$ =$DP_1$ \;
	$DP_1$ =$DP_2$ \;
	$DP_2$ =$DP_0$ + $DP_1$ \;
}
\Return DP[n]\;
\end{algorithm}
\subsection{Hateville}
Hateville \`e un villaggio composto da $n$ case numerate da $1$ a $n$ lungo una singola strada. Ad Hateville ognuno odia i propri vicini da entrambi i lati. Si vuole organizzare una sagra e si rende necessario
raccogliere i fondi. Ogni abitante ha intenzione di donare una quantit\`a $D[i]$, ma non intende partecipare ad una raccolta fondi a cui partecipano uno o entrambi i propri vicini. Si scriva un algoritmo che 
restituisca la quantit\`a massima di fondi che pu\`o essere raccolta e un algoritmo che restituisca il sottoinsieme di indici $S\subseteq\{1, \dots, n\}$ tale per cui la donazione totale $T=\sum\limits_{i\in S}D[i]$
\`e massimale.
\subsubsection{Definizione ricorsiva}
Sia $HV(i)$ uno di possibili insiemi di indici da selezionare per ottenere una donazione ottimale delle prime $i$ case di Hateville numerate $1\dots n$. $HV(n)$ \`e la soluzione del problema originale. 
Considerando vicino $i$-esimo si deve considerare se non accettare la sua donazione ($HV(i)=HV(i-1)$) o accettarla: $HV(i) = \{i\}\cup HV(i-2)$ e prendere il risultato massimo. 
\subsubsection{Sottostruttura ottima}
Sia $HV_p(i)$ il problema dato dalle prime $i$ case e $HV_s(i)$ una soluzione ottima per il problema $HV_p(i)$ e $|HV_s(i)|$ il totale di donazioni di $HV_s(i)$ ne consegue:
\begin{itemize}
\item Se $i\not\in HV_s(i)$ allora $HV_s(i) = HV_s(i-1)$.
\item Se $i\in HV_s(i)$ allora $HV_s(i) = HV_s(i-2)\cup\{i\}$.
\end{itemize}
\paragraph{Dimostrazione}
\subparagraph{$\mathbf{i\not\in HV_s(i)}$}
$HV_s(i)$ \`e una soluzione ottima anche per $HV_p(i-1)$, se cos\`i non fosse esisterebbe una soluzione $HV'_s(i-1)$ per il problema $HV_p(i)$ tale che $|HV'_s(i-1)|>|HV_s(i)|$, ma allora $HV'_S(i-1)$ sarebbe 
una soluzione per $HV_p(i)$ tale che $HV'_s(i-1)|>|HV_s(i)|$, assurdo.
\subparagraph{$\mathbf{i\in HV_s(i)}$}
$i-1\not\in HV_s(i)$, altrimenti non sarebbe una soluzione ammissibile, pertanto $HV_s(i)-\{i\}$ \`e una soluzione ottima per $HV_p(i-2)$ per il problema $HV_p(i-2)$ tale che $|HV'_s(i-2)|>|HV_s(i)-\{i\}|$, allora
$HV'_s(i-2)\cap\{i\}$ sarebbe una soluzione per $HV_p(i)$ tale che $|HV'_s(i-2)\cup\{i\}|>|HV_s(i)|$, assurdo.
\paragraph{Determinare la ricorsione}
$$
HV(i)=
\begin{cases}
\emptyset\quad& i=0\\
\{1\} & i=1\\
highest(HV(i-1), HV(i-2)\cup\{i\}) & i\ge 2
\end{cases}
$$
\paragraph{Tabella DP}
Sia $DP[i]$ il valore della massima quanti\`a di donazioni che si possono ottenere dalle prime $i$ case di Hateville. $DP[n]$ \`e il valore della soluzione ottima.
$$
DP[i]=
\begin{cases}
0 \quad& i=0\\
D[1] & i=1\\
\max(DP[i-1], DP[i-2]+D[i]) & i\ge 2
\end{cases}
$$
\subsubsection{Algoritmo iterativo}
\begin{algorithm}[H]
\DontPrintSemicolon
\SetKwComment{comment}{$\%$}{}

\SetKw{Int}{int}
\SetKw{Boolean}{boolean}
\SetKw{New}{new}
\SetKw{True}{true}
\SetKw{False}{false}
\SetKw{Not}{not}
\SetKw{And}{and}
\SetKw{Down}{down}
\SetKw{To}{to}
\SetKw{New}{new}
\SetKw{Return}{return}
\SetKw{Print}{print}

\SetKwData{Item}{Item}
\SetKwData{Mfset}{Mfset}
\SetKwData{Graph}{Graph}
\SetKwData{N}{n}
\SetKwData{Space}{ }
\SetKwData{Parent}{parent}
\SetKwData{Rank}{rank}

\SetKwFunction{Max}{max}

\SetKwFunction{Hateville}{hateville}
\SetKwFunction{Pivot}{pivot}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}

\caption{\protect\Int \protect\Hateville{\protect\Int[] D, \protect\Int n}}
\Int[] DP = \New \Int[$0\dots n$]\;
DP[0] = 0\;
DP[1] = D[1]\;
\For{\Int i = 2 \To n}{
	DP[i] = \Max{DP[i-1], DP[i-2]+D[i]}\;
}
\Return DP[n]\;
\end{algorithm}
\subsubsection{Ricostruire la soluzione originale}
Considerando l'elemento $DP[i]$ il suo valore pu\`o essere derivato considerando:
\begin{itemize}
\item Se $DP[i]=DP[i-1]$ la casa $i$ non \`e stata selezionata.
\item Se $DP[i]=DP[i-2]+D[i]$ la casa $i$ \`e stata selezionata.
\end{itemize}
Si utilizza questa informazione per ricostruire la soluzione in modo ricorsivo: per costruire la soluzione fino a $i$ si ricostruisce la soluzione fino a $i-2$ e si aggiunge $i$ o si ricostruisce la soluzione fino a $i-1$ 
senza aggiungere nulla. 
\begin{algorithm}[H]
\DontPrintSemicolon
\SetKwComment{comment}{$\%$}{}

\SetKw{Int}{int}
\SetKw{Boolean}{boolean}
\SetKw{New}{new}
\SetKw{True}{true}
\SetKw{False}{false}
\SetKw{Not}{not}
\SetKw{And}{and}
\SetKw{Down}{down}
\SetKw{To}{to}
\SetKw{New}{new}
\SetKw{Return}{return}
\SetKw{Print}{print}

\SetKwData{Item}{Item}
\SetKwData{Mfset}{Mfset}
\SetKwData{Graph}{Graph}
\SetKwData{N}{n}
\SetKwData{Space}{ }
\SetKwData{Parent}{parent}
\SetKwData{Rank}{rank}
\SetKwData{Set}{Set}

\SetKwFunction{Max}{max}
\SetKwFunction{Insert}{insert}

\SetKwFunction{Hateville}{hateville}
\SetKwFunction{Pivot}{pivot}
\SetKwFunction{Solution}{solution}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}

\caption{\protect\Set \protect\Solution{\protect\Int[] DP, \protect\Int[] D, \protect\Int i}}
\uIf{ i == 0}{
	\Return $\emptyset$\;
}
\uElseIf{i == 1}{
	\Return $\{1\}$\;
}
\uElseIf{DP[i] == DP[i-1]}{
	\Return \Solution{DP, D, i - 1}\;
}
\Else{
	\Set sol = \Solution(DP, D, i-2)\;
	sol.\Insert{i}\;
	\Return sol\;
}
\end{algorithm}
\subsubsection{Complessit\`a computazionale}
La complessit\`a computazionale di \emph{solution()} \`e $T(n)=\Theta(n)$, quella computazionale e spaziale di \emph{hateville()} \`e $T(n)=\Theta(n)$ e $S(n)=\Theta(n)$. Questa soluzione non si pu\`o 
migliorare se si vuole ricostruire la soluzione.
\subsection{Knapsack}
Dato un insieme di oggetti, ognuno caratterizzato da un peso e da un profitto e uno zaino con un limite di capacit\`a trovare un sottoinsieme di oggetti il 
cui peso sia inferiore alla capacit\`a dello zaino e il profitto sia massimale, ovvero maggiore o uguale di qualunque altro sottoinsieme di oggetti. 
\subsubsection{Caratterizzazione}
\paragraph{Input}
\begin{itemize}
\item Un vettore $w$, dove $w[i]$ \`e il peso dell'oggetto $i$-esimo.
\item Un vettore $p$, dove $p[i]$ \`e il profitto dell'oggetto $i$-esimo.
\item La capacit\`a $C$ dello zaino.
\end{itemize}
\paragraph{Output}
Un insieme $S\subseteq\{1,\dots, n\}$ tale che il volume totale deve essere minore uguale alla capacit\`a: $w(S)\sum\limits_{i\in S}w[i]<C$ e il profitto
totale sia massimizzato: $p(S)=\sum\limits_{i\in S}p[i]$.
\subsubsection{Definizione matematica del valore della soluzione}
Dato uno zaino di capacit\`a $C$ e $n$ oggetti caratterizzati da peso $w$ e profitto $p$ si definisce $DP[i][c]$ il massimo profitto che pu\`o essere 
ottenuta dai primi $i\le n$ oggetti contenuti in uno zaino di capacit\`a $c\le C$. Il massimo profitto ottenibile dal problema originale \`e rappresentato
da $DP[n][C]$.
\paragraph{Parte ricorsiva}
Considerando l'ultimo oggetto lo si pu\`o non prendere: $DP[i][c]=DP[i-1][c]$, ovvero la capacit\`a non cambia e non c'\`e profitto; se invece lo prendo
$DP[i][c]=DP[i-1][c-w[i]]+p[i]$, ovvero si sottrae il peso alla capacit\`a e si aggiunge il profitto relativo. La scelta della soluzione migliore \`e:
$$DP[i][c] = \max(DP[i-1][c], DP[i-1][c-w[i]]+p[i])$$
\paragraph{Casi base}
Il profitto massimo in caso di assenza di oggetti o di capacit\`a \`e $0$, se invece si ha capacit\`a negativa vale $-\infty$. 
\paragraph{Formula completa}
$$
DP[i][c] =
\begin{cases}
0\quad & i = 0 \lor c = 0\\
-\infty & c<0\\
\max(DP[i-1][c], DP[i-1][c-w[i]]+p[i]) & altrimenti
\end{cases}
$$
\subsubsection{Pseudocodice}
\begin{algorithm}[H]
\DontPrintSemicolon
\SetKwComment{comment}{$\%$}{}

\SetKw{Int}{int}
\SetKw{Boolean}{boolean}
\SetKw{New}{new}
\SetKw{True}{true}
\SetKw{False}{false}
\SetKw{Not}{not}
\SetKw{And}{and}
\SetKw{Down}{down}
\SetKw{To}{to}
\SetKw{New}{new}
\SetKw{Return}{return}
\SetKw{Print}{print}

\SetKwData{Item}{Item}
\SetKwData{Mfset}{Mfset}
\SetKwData{Graph}{Graph}
\SetKwData{N}{n}
\SetKwData{Space}{ }
\SetKwData{Parent}{parent}
\SetKwData{Rank}{rank}
\SetKwData{Set}{Set}

\SetKwFunction{Max}{max}
\SetKwFunction{Insert}{insert}

\SetKwFunction{KnapSack}{knapsack}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}

\caption{\protect\Int \protect\KnapSack{\protect\Int[] w, \protect\Int[] p, \protect\Int n, \protect\Int C}}
\Int[][] DP = \New \Int$[0\dots n][0\dots C]$\;
\For{\Int i = 0 \To n}{
	DP[i][0] = 0\;
}
\For{\Int c = 0 \To C}{
	DP[0][c] = 0\;
}
\For{\Int i = 1 \To n}{
	\For{\Int c = 1 \To C}{
		\uIf{w[i] < C}{
			DP[i][c] = \Max{DP[i - 1][c - w[i]] + p[i], DP[i - 1][c]}\;		
		}	
		\Else{
			DP[i][c] = DP[i - 1][c]\;		
		}
	}
}
\Return DP[n][C]
\end{algorithm}
\subsubsection{Complessit\`a computazionale}
La complessit\`a della funzione \emph{knapsack()} \`e $T(n) = O(nC)$, una complessit\`a pseudo-polinomiale in quanto sono necessari $k = \log C$ bit per 
rappresentare $C$ e pertanto la complessit\`a \`e $T(n) = O(n2^k)$.
\subsubsection{Implementazione con memoization}
Si nota come non tutti gli elementi della matrice sono necessari alla soluzione del problema. Risulta vantaggioso pertanto utilizzare la tecnica di 
memoization, in cui la tabella viene inizializzata esternamente in una funzione wrapper e il valore $-1$ viene utilizzato per identificare il valore di
una cella non calcolata. 
\begin{algorithm}[H]
\DontPrintSemicolon
\SetKwComment{comment}{$\%$}{}

\SetKw{Int}{int}
\SetKw{Boolean}{boolean}
\SetKw{New}{new}
\SetKw{True}{true}
\SetKw{False}{false}
\SetKw{Not}{not}
\SetKw{And}{and}
\SetKw{Or}{or}
\SetKw{Down}{down}
\SetKw{To}{to}
\SetKw{New}{new}
\SetKw{Return}{return}
\SetKw{Print}{print}

\SetKwData{Item}{Item}
\SetKwData{Mfset}{Mfset}
\SetKwData{Graph}{Graph}
\SetKwData{N}{n}
\SetKwData{Space}{ }
\SetKwData{Parent}{parent}
\SetKwData{Rank}{rank}
\SetKwData{Set}{Set}

\SetKwFunction{Max}{max}
\SetKwFunction{Insert}{insert}

\SetKwProg{Fn}{}{}

\SetKwFunction{KnapSack}{knapsack}
\SetKwFunction{KnapsackRec}{knapsackRec}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}

\caption{Knapsack con memoization}

\Int\Space\Fn{\KnapSack{\Int[] w, \Int[] p, \Int n, \Int C}}{
	\Int[][] DP = \New \Int$[1\dots n][1\dots C]$\;
	\For{\Int i = 1 \To n}{
		\For{\Int c = 1 \To C}{
			DP[i][c] = -1\;		
		}	
	}
	\Return \KnapsackRec{w, p, n, C, DP}\;
	
}

\Int\Space\Fn{\KnapsackRec{\Int[] w, \Int[] p, \Int i, \Int c, \Int[][] DP}}{
	\uIf{c $<$ 0}{
		\Return $-\infty$\;	
	}
	\uElseIf{i == 0 \Or c == 0}{
		\Return 0\;	
	}
	\Else{
		\If{DP[i][c] $<$ 0}{
			\Int nottaken = \KnapsackRec{w, p, i - 1, c, DP}\;
			\Int taken = \KnapsackRec{w, p, i - 1, c - w[i], DP} + p[i]\;
			DP[i][c] = \Max{nottaken, taken}\;
		}
		\Return DP[i][c]\;
	}
}


\end{algorithm}
\subsection{Knapsack senza limiti}
Dato uno zaino di capacit\`a $C$ e $n$ oggetti caratterizzati da peso $w$ e profitto $p$ si definisce $DP[i][c]$ come il massimo profitto che pu\`o essere
ottenuto dai primi $i\le n$ oggetti contenuti in uno zaino di capacit\`a $c\le C$ senza porre limiti al numero di volte che un oggetto pu\`o essere 
selezionato. Si modifica pertanto la funzione ricorsiva come:
$$
DP[i][c] =
\begin{cases}
0\quad & i = 0 \lor c = 0\\
-\infty & c<0\\
\max(DP[i][c], DP[i-1][c-w[i]]+p[i]) & altrimenti
\end{cases}
$$
In questo possibile \`e possibile semplificare la soluzione riducendo lo spazio occupato: si definisce $DP[c]$ il massimo profitto che pu\`o essere ottenuto
da tali oggetti in uno zaino di capacit\`a $c\le C$. 
$$
DP[c] =
\begin{cases}
0\quad & c = 0\\
\max\limits_{w[i]<c}\{DP[c-w[i]]+p[i]\} &  c > 0
\end{cases}
$$
\subsubsection{Implementazione tramite memoization}
\begin{algorithm}[H]
\DontPrintSemicolon
\SetKwComment{comment}{$\%$}{}

\SetKw{Int}{int}
\SetKw{Boolean}{boolean}
\SetKw{New}{new}
\SetKw{True}{true}
\SetKw{False}{false}
\SetKw{Not}{not}
\SetKw{And}{and}
\SetKw{Or}{or}
\SetKw{Down}{down}
\SetKw{To}{to}
\SetKw{New}{new}
\SetKw{Return}{return}
\SetKw{Print}{print}

\SetKwData{Item}{Item}
\SetKwData{Mfset}{Mfset}
\SetKwData{Graph}{Graph}
\SetKwData{N}{n}
\SetKwData{Space}{ }
\SetKwData{Parent}{parent}
\SetKwData{Rank}{rank}
\SetKwData{Set}{Set}

\SetKwFunction{Max}{max}
\SetKwFunction{Insert}{insert}

\SetKwProg{Fn}{}{}

\SetKwFunction{KnapSack}{knapsack}
\SetKwFunction{KnapsackRec}{knapsackRec}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}

\caption{Knapsack senza limiti con memoization}

\Int\Space\Fn{\KnapSack{\Int[] w, \Int[] p, \Int n, \Int C}}{
	\Int[] DP = \New \Int$[0\dots C]$\;
	\For{\Int c = 0 \To C}{
		DP[i] = -1\;		
	}
	\KnapsackRec{w, p, n, C, DP}\;
	\Return DP[C]\;
	
}

\Int\Space\Fn{\KnapsackRec{\Int[] w, \Int[] p, \Int n, \Int c, \Int[][] DP}}{
	\uIf{c == 0}{
		\Return 0\;	
	}
	\ElseIf{DP[c] $<$ 0}{
		DP[c] = 0\;
		\For{\Int i = 1 \To n}{
			\If{w[i] $\le$ c}{
				\Int val = \KnapsackRec{w, p, n, c - w[i], DP} + p[i]\;
				DP[c] = \Max{DP[c], val}\;			
			}		
		}
	}
	\Return DP[c]\;
}


\end{algorithm}
Attraverso questo algoritmo non \`e detto che tutti gli elementi debbano essere riempiti e la complessit\`a in spazio \`e $\Theta(C)$.
\subsubsection{Ricostruire la soluzione}
Questo approccio rende pi\`u difficile ricostruire la soluzione: si possono ispezionare tutti gli elementi per capire da dove deriva il massimo, ma 
risulta pi\`u semplice memorizzare l'indice da cui deriva il massimo. 
\paragraph{Implementazione tramite memoization}
\begin{algorithm}[H]
\DontPrintSemicolon
\SetKwComment{comment}{$\%$}{}

\SetKw{Int}{int}
\SetKw{Boolean}{boolean}
\SetKw{New}{new}
\SetKw{True}{true}
\SetKw{False}{false}
\SetKw{Not}{not}
\SetKw{And}{and}
\SetKw{Or}{or}
\SetKw{Down}{down}
\SetKw{To}{to}
\SetKw{New}{new}
\SetKw{Return}{return}
\SetKw{Print}{print}

\SetKwData{Item}{Item}
\SetKwData{Mfset}{Mfset}
\SetKwData{Graph}{Graph}
\SetKwData{N}{n}
\SetKwData{Space}{ }
\SetKwData{Parent}{parent}
\SetKwData{Rank}{rank}
\SetKwData{Set}{Set}
\SetKwData{List}{List}

\SetKwFunction{Max}{max}
\SetKwFunction{Insert}{insert}
\SetKwFunction{ListCos}{List}
\SetKwFunction{Head}{head}

\SetKwProg{Fn}{}{}

\SetKwFunction{KnapSack}{knapsack}
\SetKwFunction{KnapsackRec}{knapsackRec}
\SetKwFunction{Solution}{solution}
\SetKwFunction{}{}
\SetKwFunction{}{}
\SetKwFunction{}{}

\caption{Knapsack senza limiti con memoization}

\Int\Space\Fn{\KnapSack{\Int[] w, \Int[] p, \Int n, \Int C}}{
	\Int[] DP = \New \Int$[0\dots C]$\;
	\Int[] pos = \New \Int$[0\dots C]$\;
	\For{\Int c = 0 \To C}{
		DP[i] = -1\;
		pos[i] = -1\;		
	}
	\KnapsackRec{w, p, n, C, DP, pos}\;
	\Return \Solution{w, C, pos}\;
	
}

\Int\Space\Fn{\KnapsackRec{\Int[] w, \Int[] p, \Int n, \Int c, \Int[][] DP}}{
	\uIf{c == 0}{
		\Return 0\;	
	}
	\ElseIf{DP[c] $<$ 0}{
		DP[c] = 0\;
		\For{\Int i = 1 \To n}{
			\If{w[i] $\le$ c}{
				\Int val = \KnapsackRec{w, p, n, c - w[i], DP} + p[i]\;
				\If{val $\ge$ DP[c]}{
					DP[c] = val\;
					pos[c] = i\;
				}				
							
			}		
		}
	}
	\Return DP[c]\;
}

\List\Space\Fn{\Solution{\Int[] w, \Int c, \Int[] pos}}{
	\uIf{c == 0 \Or pos[c] $>$ 0}{
		\Return \ListCos{}\;
	}
	\Else{
		\List L = \Solution{w, c - w[pos[c]], pos}\;
		L.\Insert{L.\Head{}, pos[c]}\;
		\Return L\;	
	}
}

\end{algorithm}
Restituisce una lista di indici selezionati, se $c=0$ lo zaino \`e stato riempito perfettamente, se $pos[c]<0$ lo zaino non pu\`o essere riempito 
interamente.
\subsection{Sottosequenza comune massimale}
\paragraph{Sottosequenza}
Si definisce una sequenza $P$ come sottosequenza di $T$ se $P$ \`e ottenuto da $T$ rimuovendo uno o pi\`u dei suoi elementi o come il sottoinsieme di indici
$\{1, \dots, n\}$ degli elementi di $T$ che compaiono anche in $P$. I rimanenti elementi sono indicati in ordine senza essere necessariamente contigui. La
sottosequenza vuota $\emptyset$ \`e sottosequenza di qualsiasi altra sottosequenza. 
\paragraph{Sottosequenza comune}
Una sottosequenza $X$ \`e detta sottosequenza comune di due sequenze $T$ e $U$ se \`e sottosequenza sia di $T$ che di $U$: $X\in \mathcal{CS}(T, U)$.
\paragraph{Sottosequenza comune massimale}
Una sequenza $X\in \mathcal{CS}(T, U)$ \`e una sottosequenza comune massimale di due sequenze $T$ e $U$ se non esiste altra sottosequenza comune $Y\in 
\mathcal{CS}(T, U)$ tale che $Y$ sia pi\`u lunga di $X$, si scrive: $X\in \mathcal{LCS}(T, U)$.
\subsubsection{Definizione del problema}
Date due sequenze $T$ e $U$ si trovi la pi\`u lunga sottosequenza comune di $T$ e $U$. 
\subsubsection{Soluzione di forza bruta}
\begin{algorithm}[H]
\DontPrintSemicolon
\SetKwComment{comment}{$\%$}{}

\SetKw{Int}{int}
\SetKw{Boolean}{boolean}
\SetKw{New}{new}
\SetKw{True}{true}
\SetKw{False}{false}
\SetKw{Not}{not}
\SetKw{And}{and}
\SetKw{Or}{or}
\SetKw{Down}{down}
\SetKw{To}{to}
\SetKw{New}{new}
\SetKw{Return}{return}
\SetKw{Nil}{nil}
\SetKw{Print}{print}

\SetKwData{Item}{Item}
\SetKwData{Mfset}{Mfset}
\SetKwData{Graph}{Graph}
\SetKwData{N}{n}
\SetKwData{Space}{ }
\SetKwData{Parent}{parent}
\SetKwData{Rank}{rank}
\SetKwData{Set}{Set}
\SetKwData{List}{List}

\SetKwFunction{Max}{max}
\SetKwFunction{Insert}{insert}
\SetKwFunction{ListCos}{List}
\SetKwFunction{Head}{head}
\SetKwFunction{Len}{len}

\SetKwProg{Fn}{}{}

\SetKwFunction{KnapSack}{knapsack}
\SetKwFunction{KnapsackRec}{knapsackRec}
\SetKwFunction{Solution}{solution}
\SetKwFunction{LCS}{LCS}
\SetKwFunction{}{}
\SetKwFunction{}{}

\caption{\protect\Int \protect\LCS{\protect\Item[] T, \protect\Item[] U}}
\Item[] maxsofar = \Nil\;
\ForEach{subsequence X of T}{
	\If{X is subsequence of U }{
		\If{\Len{X} $>$ \Len{maxsofar}}{
			maxsofar = X\;		
		}	
	}
}
\Return maxsofar\;

\end{algorithm}
Si noti come data una sottosequenza lunga $n$, le sue sottosequenze sono $2^n$ e verificare che una sequenza \`e sottosequenza di un'altra sottosequenza
\`e $O(m+n)$, la complessit\`a computazionale dell'algoritmo sopra \`e pertanto $\Theta(2^n(m+n))$. 
\subsubsection{Descrizione matematica della soluzione ottima}
Data una sequenza $T$ composta da caratteri $t_1\dots t_n$, $T(i)$ denota il prefisso di $T$ dato dai primi caratteri. L'obiettivo \`e, date due sequenze
$T$ e $U$ di lunghezza $n$ e $m$, di scrivere una formula ricorsiva $LCS(T(i), U(i))$ che restituisa la LCS dei prefissi $T(i)$ e $U(i)$. 
\paragraph{Casi ricorsivi}
\subparagraph{Primo caso}
Si considerino due prefissi $T(i)$ e $U(j)$ tali per cui l'ultimo carattere coincide, $t_i = u_j$ allora: 
$$LCS(T(i), U(j)) = LCS(T(i - 1), U(j - 1))\oplus t_i$$
\subparagraph{Secondo caso}
Si considerino due prefissi $T(i)$ e $U(j)$ tali per cui l'ultimo carattere non coincide, $t_i \neq u_j$ allora: 
$$LCS(T(i), U(j)) = longest(LCS(T(i - 1), U(j)), LCS(T(i), U(j - 1)))$$
\paragraph{Casi base}
La sottosequenza pi\`u lunga quando una delle due sequenze \`e vuota, ovvero $i = 0$ o $j = 0$ \`e la sequenza vuota. 
\paragraph{Soluzione completa}
$$
LCS(T(i), U(j)) = 
\begin{cases}
\emptyset & i = 0 \lor j = 0\\
LCS(T(i - 1), U(j - 1))\oplus t_i & i > 0 \land j > 0 \land t_i = u_j\\
longest(LCS(T(i - 1), U(j)), LCS(T(i), U(j - 1))) & i > 0 \land j > 0 \land t_i \neq u_j
\end{cases}
$$